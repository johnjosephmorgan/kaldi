* Step by step file conversions
** Get some data
cp ~/mflts/Modern\ Standard\ Arabic/Speech/primary\ data\ TRAINING\ ONLY/NISTMSA_G52_sM18iM04fM19_050810_sf.wav ./
cp ~/mflts/Modern\ Standard\ Arabic/Speech/primary\ data\ TRAINING\ ONLY/NISTMSA_G52_sM18iM04fM19_050810_sif.wav ./
** Change file format from wav to flac
sox src/data/sf/wav/NISTMSA_G52_sM18iM04fM19_050810_sf.wav src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac 
sox src/data/sif/wav/NISTMSA_G52_sM18iM04fM19_050810_sif.wav src/data/sif/flac/NISTMSA_G52_sM18iM04fM19_050810_sif.flac
** Get information on new flac file
sox --i src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac 
*** info 

Input File     : 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac'
Channels       : 2
Sample Rate    : 44100
Precision      : 16-bit
Duration       : 00:22:43.34 = 60123191 samples = 102250 CDDA sectors
File Size      : 62.1M
Bit Rate       : 365k
Sample Encoding: 16-bit FLAC
Comment        : 'Comment=Processed by SoX'

** Get channel 1
sox  'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac' -c 1  'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1.flac'
** info on new channel 1 file
sox --i 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1.flac'
*** info

Input File     : 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1.flac'
Channels       : 1
Sample Rate    : 44100
Precision      : 16-bit
Duration       : 00:22:43.34 = 60123191 samples = 102250 CDDA sectors
File Size      : 32.5M
Bit Rate       : 191k
Sample Encoding: 16-bit FLAC
Comment        : 'Comment=Processed by SoX'
** Downsample to 16k 
sox 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1.flac' -r 16000 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1_16k.flac'
** Get info on downsampled recording
sox --i 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1_16k.flac'
*** info

Input File     : 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1_16k.flac'
Channels       : 1
Sample Rate    : 16000
Precision      : 16-bit
Duration       : 00:22:43.34 = 21813403 samples ~ 102250 CDDA sectors
File Size      : 14.0M
Bit Rate       : 82.4k
Sample Encoding: 16-bit FLAC
Comment        : 'Comment=Processed by SoX'

Notice the bit rate.

* Summary of file conversions
sox 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac' -c 1 -r 16000 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf_c1_16k.flac'
* First attempt at creating an overlapped recording
** Create a silence file
sox -n -r 16000 -c 1 silence_10.wav trim 0.0 10.0
** Get SAD models
*** download SAD models from kaldi webpage
wget http://kaldi-asr.org/models/12/0012_sad_v1.tar.gz
*** Unpack archive
tar -zxf 0012_sad_v1.tar.gz 
*** Put the models in the right place
mkdir -p exp
cd exp
ln -s ../0012_sad_v1/exp/segmentation_1a ./
cd ..
** Run SAD to get segmented data.
./run.sh src/data/sif/flac/NISTMSA_G52_sM18iM04fM19_050810_sif.flac
This runs clustering without a priori knowledge of the number of speakers.
It is not quite as accurate as running with the number of speakers known ahead of time.
** Copy another recording
cp ~/mflts/Modern\ Standard\ Arabic/Speech/primary\ data\ TRAINING\ ONLY/NISTMSA_G52_sM15iM14fM27_050910_sif.wav src/data/sif/wav/
sox 'src/data/sf/flac/NISTMSA_G52_sM18iM04fM19_050810_sf.flac' -c 1 -r 16000 * Convert to flac format from wav
sox src/data/sif/wav/NISTMSA_G52_sM15iM14fM27_050910_sif.wav src/data/sif/flac/NISTMSA_G52_sM15iM14fM27_050910_sif.flac
** Run diarization 
./run.sh src/data/sif/flac/NISTMSA_G52_sM15iM14fM27_050910_sif.flac 
** Pick 2 files to work with
NISTMSA_G52_sM15iM14fM27_050910_sif/audio_threshold/2/1011_32.97_36.47.wav
NISTMSA_G52_sM18iM04fM19_050810_sif/audio_threshold/2/1021_83.9_87.38.wav
** Get the durations
sox --i NISTMSA_G52_sM15iM14fM27_050910_sif/audio_threshold/2/1011_32.97_36.47.wav | grep Duration | cut -d ":" -f 2- | cut -d "=" -f 1
sox --i NISTMSA_G52_sM18iM04fM19_050810_sif/audio_threshold/2/1021_83.9_87.38.wav | grep Duration | cut -d ":" -f 2- | cut -d "=" -f 1
** Compute durations to decide overlap
...
** Create  silence file
sox -n -r 16000 -c 1 silence_1.wav trim 0.0 1.0
** Get channel 1
sox NISTMSA_G52_sM18iM04fM19_050810_sif/audio_threshold/2/1021_83.9_87.38.wav -c 1 -r 1`6000 8.wav
sox NISTMSA_G52_sM15iM14fM27_050910_sif/audio_threshold/2/1011_32.97_36.47.wav -c 1 -r 16000 5.wav
** Concatenate silence and part 2 
sox silence_1.wav 8.wav a.wav
** Merge  into a stereo recording
sox -M 5.wav a.wav b.wav
* Second try at creating an overlapped recording
** Get the data and convert it.
The following script retrieves 2 randomly selected files from the database of recordings and converts them from multichannel wav files sampled at 44100 to mono channel flac files sampled at 16000.
local/get_and_convert_data.sh
** Download kaldi models for SAD and Diarization 
local/download_kaldi_models.sh
** Perform Diarization
for f in flacs/*; do
  ./run.sh $f
done
** Get information from segmented files.
local/get_info.sh
This writes a file with 1 record per segment.
Each record has 2 fields, the file name and the number of samples in the file.
** Create a silence file.
local/make_silent_buffer_file.pl
This creates a silent file for each segment file.
This is not quite what I need.
I need to get a silent buffer for a specific file.
I wrote a script that loops over all the segment files and runs the above script.
local/make_silent_buffer_file.sh
** Create overlap file
*** Pick a random file
a=$(find out_diarized -type f -name "*.wav" \! -name "sil_*"  | shuf -n 1)
*** Pick another file
b=$(find out_diarized -type f -name "*.wav" \! -name "sil_*"  | shuf -n 1)
*** Concatenate a's silent file with b.
a_base=$(basename $a)
a_dir=$(dirname $a)
a_sil=$a_dir/sil_${a_base}
sox $a_sil $b c.wav
** Make a stereo file with a on channel 1 and c.wav on channel 2.
sox $a c.wav -c 2 stereo.wav -M
* Third Attempt
The previous attempt is incorrect.
The overlap was computed only using the number of samples in the first file.
This is incorrect.
Consider the example:
a has 10 samples
b has 20 samples
20% of a is 2 samples.
I was starting the overlap at 8 samples.
The overlap file c would have 28 samples.
But 20 %  of 28 is  5.6 
So the overlap should start at either 4 or 5  not 8 samples.
I need the resulting file to have 20% overlap.

** pseudo code
seg_1 = c_1
seg_2 = c_2
target_percent_overlap=p
current_total> = |seg_1| + |seg_2|
current_overlap_distance = 0
marker(0) = |seg_1| + |seg_2|
marker(1) = 0
shift(1) = | marker(1) - marker(0) | / 2
marker(2) = shift(1) + |marker(1) |
current_overlap_distance = | |seg_1| - marker(2) |
current_total = marker(2) + | seg_2|
current_overlap_percentage = current_overlap_distance / current_total
if current_overlap_percentage = target_percent then write marker(2)
else if current_overlap_percentage < target_percentage then 
marker(3) = | marker(2) - marker(1) | / 2 - marker(2)
else if current_overlap_percentage > target_percentage then 
marker(3) = | marker(2) - marker(1) | / 2 + marker(2)
.
.
.
* Fourth Attempt:
Use arrays.
Store the samples in the first segment into an array
Step back from the end of the array.
At each step compute:
- Total length
- overlap length
- Percent of overlap
Stop when step crosses target percentage.
** Pseudo code:
input: segment1 segment2 Target_percentage

store segment 1 in an array

Initialize variables:
current_total_length=length(segmetnt1) + length(segment2)
current_overlap_length=0
current_overlap_percentage=0

for i=length(segment1) + length( segment2), i=0; i--; do
current_total_length -= i
current_overlap += i
current_overlap_percentage = current_overlap_length / current_total_length
if current_overlap_percentage >= target_overlap_percentage then
write length(segment1) - i



